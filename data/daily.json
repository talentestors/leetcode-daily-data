{
  "id": "1536",
  "title": "Minimum Swaps to Arrange a Binary Grid",
  "title_zh": "排布二进制网格的最少交换次数",
  "slug": "minimum-swaps-to-arrange-a-binary-grid",
  "link": "https://leetcode.cn/problems/minimum-swaps-to-arrange-a-binary-grid/",
  "content": "<p>Given an <code>n x n</code> binary <code>grid</code>, in one step you can choose two <strong>adjacent rows</strong> of the grid and swap them.</p><p>A grid is said to be <strong>valid</strong> if all the cells above the main diagonal are <strong>zeros</strong>.</p><p>Return <em>the minimum number of steps</em> needed to make the grid valid, or <strong>-1</strong> if the grid cannot be valid.</p><p>The main diagonal of a grid is the diagonal that starts at cell <code>(1, 1)</code> and ends at cell <code>(n, n)</code>.</p><p> </p><p><strong class=\"example\">Example 1:</strong></p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/28/fw.jpg\" style=\"width: 750px; height: 141px;\" /><pre><strong>Input:</strong> grid = [[0,0,1],[1,1,0],[1,0,0]]<strong>Output:</strong> 3</pre><p><strong class=\"example\">Example 2:</strong></p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/16/e2.jpg\" style=\"width: 270px; height: 270px;\" /><pre><strong>Input:</strong> grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]<strong>Output:</strong> -1<strong>Explanation:</strong> All rows are similar, swaps have no effect on the grid.</pre><p><strong class=\"example\">Example 3:</strong></p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/16/e3.jpg\" style=\"width: 200px; height: 200px;\" /><pre><strong>Input:</strong> grid = [[1,0,0],[1,1,0],[1,1,1]]<strong>Output:</strong> 0</pre><p> </p><p><strong>Constraints:</strong></p><ul><li><code>n == grid.length</code> <code>== grid[i].length</code></li><li><code>1 <= n <= 200</code></li><li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code></li></ul>",
  "translatedContent": "<p>给你一个 <code>n x n</code> 的二进制网格 <code>grid</code>，每一次操作中，你可以选择网格的 <strong>相邻两行</strong> 进行交换。</p><p>一个符合要求的网格需要满足主对角线以上的格子全部都是 <strong>0</strong> 。</p><p>请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 <strong>-1</strong> 。</p><p>主对角线指的是从 <code>(1, 1)</code> 到 <code>(n, n)</code> 的这些格子。</p><p> </p><p><strong>示例 1：</strong></p><p><img alt=\"\" src=\"https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/08/02/fw.jpg\" style=\"height: 141px; width: 750px;\"></p><pre><strong>输入：</strong>grid = [[0,0,1],[1,1,0],[1,0,0]]<strong>输出：</strong>3</pre><p><strong>示例 2：</strong></p><p><img alt=\"\" src=\"https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/08/02/e2.jpg\" style=\"height: 270px; width: 270px;\"></p><pre><strong>输入：</strong>grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]<strong>输出：</strong>-1<strong>解释：</strong>所有行都是一样的，交换相邻行无法使网格符合要求。</pre><p><strong>示例 3：</strong></p><p><img alt=\"\" src=\"https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/08/02/e3.jpg\" style=\"height: 210px; width: 210px;\"></p><pre><strong>输入：</strong>grid = [[1,0,0],[1,1,0],[1,1,1]]<strong>输出：</strong>0</pre><p> </p><p><strong>提示：</strong></p><ul><li><code>n == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 <= n <= 200</code></li><li><code>grid[i][j]</code> 要么是 <code>0</code> 要么是 <code>1</code> 。</li></ul>",
  "difficulty": "Medium",
  "topicTags": [
    {
      "name": "Greedy",
      "slug": "greedy",
      "translatedName": "贪心"
    },
    {
      "name": "Array",
      "slug": "array",
      "translatedName": "数组"
    },
    {
      "name": "Matrix",
      "slug": "matrix",
      "translatedName": "矩阵"
    }
  ],
  "date": "2026-03-02"
}