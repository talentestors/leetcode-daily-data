{
  "id": "3013",
  "title": "Divide an Array Into Subarrays With Minimum Cost II",
  "title_zh": "将数组分成最小总代价的子数组 II",
  "slug": "divide-an-array-into-subarrays-with-minimum-cost-ii",
  "link": "https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/",
  "content": "<p>You are given a <strong>0-indexed</strong> array of integers <code>nums</code> of length <code>n</code>, and two <strong>positive</strong> integers <code>k</code> and <code>dist</code>.</p><p>The <strong>cost</strong> of an array is the value of its <strong>first</strong> element. For example, the cost of <code>[1,2,3]</code> is <code>1</code> while the cost of <code>[3,4,1]</code> is <code>3</code>.</p><p>You need to divide <code>nums</code> into <code>k</code> <strong>disjoint contiguous </strong><span data-keyword=\"subarray-nonempty\">subarrays</span>, such that the difference between the starting index of the <strong>second</strong> subarray and the starting index of the <code>kth</code> subarray should be <strong>less than or equal to</strong> <code>dist</code>. In other words, if you divide <code>nums</code> into the subarrays <code>nums[0..(i<sub>1</sub> - 1)], nums[i<sub>1</sub>..(i<sub>2</sub> - 1)], ..., nums[i<sub>k-1</sub>..(n - 1)]</code>, then <code>i<sub>k-1</sub> - i<sub>1</sub> <= dist</code>.</p><p>Return <em>the <strong>minimum</strong> possible sum of the cost of these</em> <em>subarrays</em>.</p><p> </p><p><strong class=\"example\">Example 1:</strong></p><pre><strong>Input:</strong> nums = [1,3,2,6,4,2], k = 3, dist = 3<strong>Output:</strong> 5<strong>Explanation:</strong> The best possible way to divide nums into 3 subarrays is: [1,3], [2,6,4], and [2]. This choice is valid because i<sub>k-1</sub> - i<sub>1</sub> is 5 - 2 = 3 which is equal to dist. The total cost is nums[0] + nums[2] + nums[5] which is 1 + 2 + 2 = 5.It can be shown that there is no possible way to divide nums into 3 subarrays at a cost lower than 5.</pre><p><strong class=\"example\">Example 2:</strong></p><pre><strong>Input:</strong> nums = [10,1,2,2,2,1], k = 4, dist = 3<strong>Output:</strong> 15<strong>Explanation:</strong> The best possible way to divide nums into 4 subarrays is: [10], [1], [2], and [2,2,1]. This choice is valid because i<sub>k-1</sub> - i<sub>1</sub> is 3 - 1 = 2 which is less than dist. The total cost is nums[0] + nums[1] + nums[2] + nums[3] which is 10 + 1 + 2 + 2 = 15.The division [10], [1], [2,2,2], and [1] is not valid, because the difference between i<sub>k-1</sub> and i<sub>1</sub> is 5 - 1 = 4, which is greater than dist.It can be shown that there is no possible way to divide nums into 4 subarrays at a cost lower than 15.</pre><p><strong class=\"example\">Example 3:</strong></p><pre><strong>Input:</strong> nums = [10,8,18,9], k = 3, dist = 1<strong>Output:</strong> 36<strong>Explanation:</strong> The best possible way to divide nums into 4 subarrays is: [10], [8], and [18,9]. This choice is valid because i<sub>k-1</sub> - i<sub>1</sub> is 2 - 1 = 1 which is equal to dist.The total cost is nums[0] + nums[1] + nums[2] which is 10 + 8 + 18 = 36.The division [10], [8,18], and [9] is not valid, because the difference between i<sub>k-1</sub> and i<sub>1</sub> is 3 - 1 = 2, which is greater than dist.It can be shown that there is no possible way to divide nums into 3 subarrays at a cost lower than 36.</pre><p> </p><p><strong>Constraints:</strong></p><ul><li><code>3 <= n <= 10<sup>5</sup></code></li><li><code>1 <= nums[i] <= 10<sup>9</sup></code></li><li><code>3 <= k <= n</code></li><li><code>k - 2 <= dist <= n - 2</code></li></ul>",
  "translatedContent": "<p>给你一个下标从 <strong>0</strong> 开始长度为 <code>n</code> 的整数数组 <code>nums</code> 和两个 <strong>正</strong> 整数 <code>k</code> 和 <code>dist</code> 。</p><p>一个数组的 <strong>代价</strong> 是数组中的 <strong>第一个</strong> 元素。比方说，<code>[1,2,3]</code> 的代价为 <code>1</code> ，<code>[3,4,1]</code> 的代价为 <code>3</code> 。</p><p>你需要将 <code>nums</code> 分割成 <code>k</code> 个 <strong>连续且互不相交</strong> 的<span data-keyword=\"subarray\">子数组</span>，满足 <strong>第二</strong> 个子数组与第 <code>k</code> 个子数组中第一个元素的下标距离 <strong>不超过</strong> <code>dist</code> 。换句话说，如果你将 <code>nums</code> 分割成子数组 <code>nums[0..(i<sub>1</sub> - 1)], nums[i<sub>1</sub>..(i<sub>2</sub> - 1)], ..., nums[i<sub>k-1</sub>..(n - 1)]</code> ，那么它需要满足 <code>i<sub>k-1</sub> - i<sub>1</sub> <= dist</code> 。</p><p>请你返回这些子数组的 <strong>最小</strong> 总代价。</p><p> </p><p><strong class=\"example\">示例 1：</strong></p><pre><b>输入：</b>nums = [1,3,2,6,4,2], k = 3, dist = 3<b>输出：</b>5<b>解释：</b>将数组分割成 3 个子数组的最优方案是：[1,3] ，[2,6,4] 和 [2] 。这是一个合法分割，因为 i<sub>k-1</sub> - i<sub>1</sub> 等于 5 - 2 = 3 ，等于 dist 。总代价为 nums[0] + nums[2] + nums[5] ，也就是 1 + 2 + 2 = 5 。5 是分割成 3 个子数组的最小总代价。</pre><p><strong class=\"example\">示例 2：</strong></p><pre><strong>输入：</strong>nums = [10,1,2,2,2,1], k = 4, dist = 3<b>输出：</b>15<b>解释：</b>将数组分割成 4 个子数组的最优方案是：[10] ，[1] ，[2] 和 [2,2,1] 。这是一个合法分割，因为 i<sub>k-1</sub> - i<sub>1</sub> 等于 3 - 1 = 2 ，小于 dist 。总代价为 nums[0] + nums[1] + nums[2] + nums[3] ，也就是 10 + 1 + 2 + 2 = 15 。分割 [10] ，[1] ，[2,2,2] 和 [1] 不是一个合法分割，因为 i<sub>k-1</sub> 和 i<sub>1</sub> 的差为 5 - 1 = 4 ，大于 dist 。15 是分割成 4 个子数组的最小总代价。</pre><p><strong class=\"example\">示例 3：</strong></p><pre><b>输入：</b>nums = [10,8,18,9], k = 3, dist = 1<b>输出：</b>36<b>解释：</b>将数组分割成 4 个子数组的最优方案是：[10] ，[8] 和 [18,9] 。这是一个合法分割，因为 i<sub>k-1</sub> - i<sub>1</sub> 等于 2 - 1 = 1 ，等于 dist 。总代价为 nums[0] + nums[1] + nums[2] ，也就是 10 + 8 + 18 = 36 。分割 [10] ，[8,18] 和 [9] 不是一个合法分割，因为 i<sub>k-1</sub> 和 i<sub>1</sub> 的差为 3 - 1 = 2 ，大于 dist 。36 是分割成 3 个子数组的最小总代价。</pre><p> </p><p><strong>提示：</strong></p><ul><li><code>3 <= n <= 10<sup>5</sup></code></li><li><code>1 <= nums[i] <= 10<sup>9</sup></code></li><li><code>3 <= k <= n</code></li><li><code>k - 2 <= dist <= n - 2</code></li></ul>",
  "difficulty": "Hard",
  "topicTags": [
    {
      "name": "Array",
      "slug": "array",
      "translatedName": "数组"
    },
    {
      "name": "Hash Table",
      "slug": "hash-table",
      "translatedName": "哈希表"
    },
    {
      "name": "Sliding Window",
      "slug": "sliding-window",
      "translatedName": "滑动窗口"
    },
    {
      "name": "Heap (Priority Queue)",
      "slug": "heap-priority-queue",
      "translatedName": "堆（优先队列）"
    }
  ],
  "date": "2026-02-02"
}